<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>10 Most Common JavaScript Mistakes | Yiming @ SeasonsRoad</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Today, JavaScript is at the core of virtually all modern web applications. The past several years in particular have witnessed the proliferation of a wide array of powerful JavaScript-based libraries">
<meta property="og:type" content="article">
<meta property="og:title" content="10 Most Common JavaScript Mistakes">
<meta property="og:url" content="http://blog.seasonsroad.com/2015/06/10MostCommonJavaScriptMistakes/index.html">
<meta property="og:site_name" content="Yiming @ SeasonsRoad">
<meta property="og:description" content="Today, JavaScript is at the core of virtually all modern web applications. The past several years in particular have witnessed the proliferation of a wide array of powerful JavaScript-based libraries">
<meta property="og:image" content="http://blog.seasonsroad.com/JavaScriptNotWorking.png">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="10 Most Common JavaScript Mistakes">
<meta name="twitter:description" content="Today, JavaScript is at the core of virtually all modern web applications. The past several years in particular have witnessed the proliferation of a wide array of powerful JavaScript-based libraries">
  
    <link rel="alternative" href="/atom.xml" title="Yiming @ SeasonsRoad" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-nav" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Good Morning!</a>
      </h1>
      <nav id="main-nav">
        <ul class="mod-head__ul">
        
          <li class="main-nav-link"><a href="/">Home</a></li>
        
          <li class="main-nav-link"><a href="/links.html">Links</a></li>
        
          <li class="main-nav-link"><a href="https://github.com/yiminglu">Github</a></li>
        
          <li class="main-nav-link"><a href="/about.html">About</a></li>
        
        </ul>
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
      </nav>
    </div>
  </div>
</header>
      <div class="inner">
        <section id="main"><article id="post-10MostCommonJavaScriptMistakes" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/06/10MostCommonJavaScriptMistakes/" class="article-date">
  <p><time datetime="2015-06-08T06:36:19.000Z" itemprop="datePublished">2015/06/08</time></p>
</a>

      
  <div class="article-category">
    <a class="article-category-link" href="/categories/Develop/">Develop</a>
  </div>

    </div>
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      <a href="/2015/06/10MostCommonJavaScriptMistakes/">
        10 Most Common JavaScript Mistakes
      </a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Today, <a href="http://en.wikipedia.org/wiki/JavaScript" target="_blank" rel="external">JavaScript</a> is at the core of virtually all modern web applications. The past several years in particular have witnessed the proliferation of a wide array of powerful JavaScript-based libraries and frameworks for <a href="http://en.wikipedia.org/wiki/Single-page_application" target="_blank" rel="external">single page application (SPA)</a> development, graphics and animation, and even server-side JavaScript platforms. JavaScript has truly become ubiquitous in the world of web app development and is therefore an increasingly important skill to master.</p>
<p>At first blush, JavaScript may seem quite simple. And indeed, to build basic JavaScript functionality into a web page is a fairly straightforward task for any experienced software developer, even if they’re new to JavaScript. Yet the language is significantly more nuanced, powerful, and complex than one would initially be lead to believe. <strong>Indeed, many of JavaScript’s subtleties lead to a number of common problems that keep it from working – 10 of which we discuss here – that are important to be aware of and avoid in one’s quest to become a <a href="http://www.toptal.com/javascript" target="_blank" rel="external">master JavaScript developer</a>.</strong></p>
<p><img src="JavaScriptNotWorking.png" alt="This developer&#39;s JavaScript is full of problems and bugs."></p>
<h2 id="Common_Mistake_#1:_Incorrect_references_to_this">Common Mistake #1: Incorrect references to <code>this</code></h2><p>I once heard a comedian say:</p>
<blockquote>
<p><em>“I’m not really</em> <strong><em>here</em></strong><em>, because what’s</em> <strong><em>here</em></strong><em>, besides</em> <strong><em>there</em></strong><em>, without the</em> <strong><em>‘t’</em></strong><em>?”</em></p>
</blockquote>
<p>That joke in many ways characterizes the type of confusion that often exists for developers regarding <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this" target="_blank" rel="external">JavaScript’s <code>this</code> keyword</a>. I mean, is <code>this</code> really this, or is it something else entirely? Or is it undefined?</p>
<p>As JavaScript coding techniques and design patterns have become increasingly sophisticated over the years, there’s been a corresponding increase in the proliferation of self-referencing scopes within callbacks and closures, which are a fairly common source of “this/that confusion”.</p>
<p>Consider this example code snippet:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Game.prototype.restart = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.clearLocalStorage();</span><br><span class="line">  <span class="keyword">this</span>.timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.clearBoard();    <span class="comment">// what is "this"?</span></span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Executing the above code results in the following error:</p>
<pre><code>Uncaught TypeError: undefined is <span class="operator">not</span> <span class="operator">a</span> <span class="function"><span class="keyword">function</span></span>
</code></pre><p>Why?</p>
<p>It’s all about context. The reason you get the above error is because, when you invoke <code>setTimeout()</code>, you are actually invoking <code>window.setTimeout()</code>. As a result, the anonymous function being passed to <code>setTimeout()</code> is being defined in the context of the <code>window</code> object, which has no <code>clearBoard()</code> method.</p>
<p>A traditional, old-browser-compliant solution is to simply save your reference to <code>this</code> in a variable that can then be inherited by the closure; e.g.:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Game.prototype.restart = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.clearLocalStorage();</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;   <span class="comment">// save reference to 'this', while it's still this!</span></span><br><span class="line">  <span class="keyword">this</span>.timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    self.clearBoard();    <span class="comment">// oh OK, I do know who 'self' is!</span></span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Alternatively, in newer browsers, you can use the <code>bind()</code> method to pass in the proper reference:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Game.prototype.restart = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.clearLocalStorage();</span><br><span class="line">  <span class="keyword">this</span>.timer = setTimeout(<span class="keyword">this</span>.reset.bind(<span class="keyword">this</span>), <span class="number">0</span>);  <span class="comment">// bind to 'this'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Game.prototype.reset = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.clearBoard();    <span class="comment">// ahhh, back in the context of the right 'this'!</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Common_Mistake_#2:_Thinking_there_is_block-level_scope">Common Mistake #2: Thinking there is block-level scope</h2><p>As discussed in our <a href="http://www.toptal.com/javascript/#hiring-guide" target="_blank" rel="external">JavaScript Hiring Guide</a>, a common source of confusion among JavaScript developers (and therefore a common source of bugs) is assuming that JavaScript creates a new scope for each code block. Although this is true in many other languages, it is <em>not</em> true in JavaScript. Consider, for example, the following code:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i);  <span class="comment">// what will this output?</span></span><br></pre></td></tr></table></figure>
<p>If you guess that the <code>console.log()</code> call would either output <code>undefined</code> or throw an error, you guessed incorrectly. Believe it or not, it will output <code>10</code>. Why?</p>
<p>In most other languages, the code above would lead to an error because the “life” (i.e., scope) of the variable <code>i</code> would be restricted to the <code>for</code> block. In JavaScript, though, this is not the case and the variable <code>i</code> remains in scope even after the <code>for</code> loop has completed, retaining its last value after exiting the loop. (This behavior is known, incidentally, as <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var#var_hoisting" target="_blank" rel="external">variable hoisting</a>).</p>
<p>It is worth noting, though, that support for block-level scopes <em>is</em> making its way into JavaScript through the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let" target="_blank" rel="external">new <code>let</code> keyword</a>. The <code>let</code> keyword is already available in JavaScript 1.7 and is slated to become an officially supported JavaScript keyword as of <a href="https://people.mozilla.org/~jorendorff/es6-draft.html" target="_blank" rel="external">ECMAScript 6</a>.</p>
<p>New to JavaScript? Read up on <a href="http://www.toptal.com/javascript/javascript-prototypes-scopes-and-performance-what-you-need-to-know" target="_blank" rel="external">scopes, prototypes, and more.</a></p>
<h2 id="Common_Mistake_#3:_Creating_memory_leaks">Common Mistake #3: Creating memory leaks</h2><p>Memory leaks are almost inevitable JavaScript problems if you’re not consciously coding to avoid them. There are numerous ways for them to occur, so we’ll just highlight a couple of their more common occurrences.</p>
<p><strong>Memory Leak Example 1: Dangling references to defunct objects</strong></p>
<p>Consider the following code:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> theThing = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> replaceThing = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> priorThing = theThing;  <span class="comment">// hold on to the prior thing</span></span><br><span class="line">  <span class="keyword">var</span> unused = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 'unused' is the only place where 'priorThing' is referenced,</span></span><br><span class="line">    <span class="comment">// but 'unused' never gets invoked</span></span><br><span class="line">    <span class="keyword">if</span> (priorThing) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"hi"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  theThing = &#123;</span><br><span class="line">    longStr: <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1000000</span>).join(<span class="string">'*'</span>),  <span class="comment">// create a 1MB object</span></span><br><span class="line">    someMethod: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(someMessage);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">setInterval(replaceThing, <span class="number">1000</span>);    <span class="comment">// invoke `replaceThing' once every second</span></span><br></pre></td></tr></table></figure>
<p><em>If you run the above code and monitor memory usage, you’ll find that you’ve got a massive memory leak, leaking a full megabyte per second!</em> And even a manual GC doesn’t help. So it looks like we are leaking <code>longStr</code> every time <code>replaceThing</code> is called. But why?</p>
<p>Let’s examine things in more detail:</p>
<p>Each <code>theThing</code> object contains its own 1MB <code>longStr</code> object. Every second, when we call <code>replaceThing</code>, it holds on to a reference to the prior <code>theThing</code> object in <code>priorThing</code>. But we still wouldn’t think this would be a problem, since each time through, the previously referenced <code>priorThing</code> would be dereferenced (when <code>priorThing</code> is reset via <code>priorThing = theThing;</code>). And moreover, is only referenced in the main body of <code>replaceThing</code> and in the function <code>unused</code> which is, in fact, never used.</p>
<p>So again we’re left wondering why there is a memory leak here!?</p>
<p>To understand what’s going on, we need to better understand how things are working in JavaScript under the hood. The typical way that closures are implemented is that every function object has a link to a dictionary-style object representing its lexical scope. If both functions defined inside <code>replaceThing</code> actually used <code>priorThing</code>, it would be important that they both get the same object, even if <code>priorThing</code> gets assigned to over and over, so both functions share the same lexical environment. But as soon as a variable is used by any closure, it ends up in the lexical environment shared by all closures in that scope. And that little nuance is what leads to this gnarly memory leak. (More detail on this is available <a href="https://www.meteor.com/blog/2013/08/13/an-interesting-kind-of-javascript-memory-leak" target="_blank" rel="external">here</a>.)</p>
<p><strong>Memory Leak Example 2: Circular references</strong></p>
<p>Consider this code fragment:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addClickHandler</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">    element.click = <span class="function"><span class="keyword">function</span> <span class="title">onClick</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">"Clicked the "</span> + element.nodeName)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Here, <code>onClick</code> has a closure which keeps a reference to <code>element</code> (via <code>element.nodeName</code>). By also assigning <code>onClick</code> to <code>element.click</code>, the circular reference is created; i.e.: <code>element</code> -&gt; <code>onClick</code> -&gt; <code>element</code> -&gt; <code>onClick</code> -&gt; <code>element</code>…</p>
<p>Interestingly, even if <code>element</code> is removed from the DOM, the circular self-reference above would prevent <code>element</code> and <code>onClick</code> from being collected, and hence, a memory leak.</p>
<p><strong>Avoiding Memory Leaks: What you need to know</strong></p>
<p>JavaScript’s memory management (and, in paticular, <a href="http://en.wikipedia.org/wiki/Garbage_collection_(computer_science" target="_blank" rel="external">garbage collection</a>)) is largely based on the notion of object <a href="http://javascript.info/tutorial/memory-leaks#memory-management-in-javascript" target="_blank" rel="external">reachability</a>.</p>
<p>The following objects are assumed to be <em>reachable</em> and are known as “roots”:</p>
<ul>
<li>Objects referenced from anywhere in the current <em>call stack</em> (that is, all local variables and parameters in the functions currently being invoked, and all the variables in the closure scope)</li>
<li>All <em>global</em> variables</li>
</ul>
<p><em>Objects are kept in memory at least as long as they are accessible from any of the roots through a reference, or a chain of references.</em></p>
<p>There is a Garbage Collector (GC) in the browser which cleans memory occupied by unreachable objects; i.e., objects will be removed from memory <em>if and only if</em> the GC believes that they are unreachable. Unfortunately, it’s fairly easy to end up with defunct “zombie” objects that are in fact no longer in use but that the GC still thinks are “reachable”.</p>
<h2 id="Common_Mistake_#4:_Confusion_about_equality">Common Mistake #4: Confusion about equality</h2><p>One of the conveniences in JavaScript is that it will automatically coerce any value being referenced in a boolean context to a boolean value. But there are cases where this can be as confusing as it is convenient. Some of the following, for example, have been known to bite many a JavaScript developer:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// All of these evaluate to 'true'!</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">false</span> == <span class="string">'0'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> == <span class="literal">undefined</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">" \t\r\n"</span> == <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">''</span> == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// And these do too!</span></span><br><span class="line"><span class="keyword">if</span> (&#123;&#125;) <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">if</span> ([]) <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>With regard to the last two, despite being empty (which might lead one to believe that they would evaluate to <code>false</code>), both <code>{}</code> and <code>[]</code> are in fact objects and <em>any</em> object will be coerced to a boolean value of <code>true</code> in JavaScript, consistent with the <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-9.2" target="_blank" rel="external">ECMA-262 specification</a>.</p>
<p>As these examples demonstrate, the rules of type coercion can sometimes be clear as mud. Accordingly, unless type coercion is explicitly desired, it’s typically best to use <code>===</code> and <code>!==</code> (rather than <code>==</code> and <code>!=</code>), so as to avoid any unintended side-effects of type coercion. (<code>==</code> and <code>!=</code> automatically perform type conversion when comparing two things, whereas <code>===</code> and <code>!==</code> do the same comparison without type conversion.)</p>
<p>And completely as a sidepoint – but since we’re talking about type coercion and comparisons – it’s worth mentioning that comparing <code>NaN</code> with <em>anything</em> (even <code>NaN</code>!) will <em>always</em> return <code>false</code>. <em>You therefore cannot use the equality operators (<code>==</code>, <code>===</code>, <code>!=</code>, <code>!==</code>) to determine whether a value is <code>NaN</code> or not.</em> Instead, use the built-in global <code>isNaN()</code> function:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> == <span class="literal">NaN</span>);    <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> === <span class="literal">NaN</span>);   <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="literal">NaN</span>));    <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="Common_Mistake_#5:_Inefficient_DOM_manipulation">Common Mistake #5: Inefficient DOM manipulation</h2><p>JavaScript makes it relatively easy to manipulate the DOM (i.e., add, modify, and remove elements), but does nothing to promote doing so efficiently.</p>
<p>A common example is code that adds a series of DOM Elements one at a time. Adding a DOM element is an expensive operation. Code that adds multiple DOM elements consecutively is inefficient and likely not to work well.</p>
<p>One effective alternative when multiple DOM elements need to be added is to use <a href="https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment" target="_blank" rel="external">document fragments</a> instead, thereby improving both efficiency and performance.</p>
<p>For example:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"my_div"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> e = <span class="number">0</span>; e &lt; elems.length; e++) &#123;  <span class="comment">// elems previously set to list of elements</span></span><br><span class="line">    fragment.appendChild(elems[e]);</span><br><span class="line">&#125;</span><br><span class="line">div.appendChild(fragment.cloneNode(<span class="literal">true</span>));</span><br></pre></td></tr></table></figure>
<p>In addition to the inherently improved efficiency of this approach, creating attached DOM elements is expensive, whereas creating and modifying them while detached and then attaching them yields much better performance.</p>
<h2 id="Common_Mistake_#6:_Incorrect_use_of_function_definitions_inside_for_loops">Common Mistake #6: Incorrect use of function definitions inside <code>for</code> loops</h2><p>Consider this code:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elements = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'input'</span>);</span><br><span class="line"><span class="keyword">var</span> n = elements.length;    <span class="comment">// assume we have 10 elements for this example</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    elements[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"This is element #"</span> + i);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Based on the above code, if there were 10 input elements, clicking <em>any</em> of them would display “This is element #10”! This is because, by the time <code>onclick</code> is invoked for <em>any</em> of the elements, the above for loop will have completed and the value of <code>i</code> will already be 10 (for <em>all</em> of them).</p>
<p>Here’s how we can correct the above code problems, though, to achieve the desired behavior:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elements = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'input'</span>);</span><br><span class="line"><span class="keyword">var</span> n = elements.length;    <span class="comment">// assume we have 10 elements for this example</span></span><br><span class="line"><span class="keyword">var</span> makeHandler = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;  <span class="comment">// outer function</span></span><br><span class="line">     <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;   <span class="comment">// inner function</span></span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">"This is element #"</span> + num);</span><br><span class="line">     &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    elements[i].onclick = makeHandler(i+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In this revised version of the code, <code>makeHandler</code> is immediately executed each time we pass through the loop, each time receiving the then-current value of <code>i+1</code> and binding it to a scoped <code>num</code> variable. The outer function returns the inner function (which also uses this scoped <code>num</code> variable) and the element’s <code>onclick</code> is set to that inner function. This ensures that each <code>onclick</code> receives and uses the proper <code>i</code> value (via the scoped <code>num</code> variable).</p>
<h2 id="Common_Mistake_#7:_Failure_to_properly_leverage_prototypal_inheritance">Common Mistake #7: Failure to properly leverage prototypal inheritance</h2><p>A surprisingly high percentage of JavaScript developers fail to fully understand, and therefore to fully leverage, the features of prototypal inheritance.</p>
<p>Here’s a simple example. Consider this code:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BaseObject = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> name !== <span class="string">"undefined"</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">'default'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Seems fairly straightforward. If you provide a name, use it, otherwise set the name to ‘default’; e.g.:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> firstObj = <span class="keyword">new</span> BaseObject();</span><br><span class="line"><span class="keyword">var</span> secondObj = <span class="keyword">new</span> BaseObject(<span class="string">'unique'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(firstObj.name);  <span class="comment">// -&gt; Results in 'default'</span></span><br><span class="line"><span class="built_in">console</span>.log(secondObj.name); <span class="comment">// -&gt; Results in 'unique'</span></span><br></pre></td></tr></table></figure>
<p>But what if we were to do this:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> secondObj.name;</span><br></pre></td></tr></table></figure>
<p>We’d then get:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(secondObj.name); <span class="comment">// -&gt; Results in 'undefined'</span></span><br></pre></td></tr></table></figure>
<p>But wouldn’t it be nicer for this to revert to ‘default’? This can easily be done, if we modify the original code to leverage prototypal inheritance, as follows:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BaseObject = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> name !== <span class="string">"undefined"</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">BaseObject.prototype.name = <span class="string">'default'</span>;</span><br></pre></td></tr></table></figure>
<p>With this version, <code>BaseObject</code> inherits the <code>name</code> property from its <code>prototype</code> object, where it is set (by default) to <code>&#39;default&#39;</code>. Thus, if the constructor is called without a name, the name will default to <code>default</code>. And similarly, if the <code>name</code> property is removed from an instance of <code>BaseObject</code>, the prototype chain will then be searched and the <code>name</code> property will be retrieved from the <code>prototype</code> object where its value is still <code>&#39;default&#39;</code>. So now we get:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> thirdObj = <span class="keyword">new</span> BaseObject(<span class="string">'unique'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(thirdObj.name);  <span class="comment">// -&gt; Results in 'unique'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> thirdObj.name;</span><br><span class="line"><span class="built_in">console</span>.log(thirdObj.name);  <span class="comment">// -&gt; Results in 'default'</span></span><br></pre></td></tr></table></figure>
<h2 id="Common_Mistake_#8:_Creating_incorrect_references_to_instance_methods">Common Mistake #8: Creating incorrect references to instance methods</h2><p>Let’s define a simple object, and create and instance of it, as follows:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyObject = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">MyObject.prototype.whoAmI = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span> ? <span class="string">"window"</span> : <span class="string">"MyObj"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> MyObject();</span><br></pre></td></tr></table></figure>
<p>Now, for convenience, let’s create a reference to the <code>whoAmI</code> method, presumably so we can access it merely by <code>whoAmI()</code> rather than the longer <code>obj.whoAmI()</code>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> whoAmI = obj.whoAmI;</span><br></pre></td></tr></table></figure>
<p>And just to be sure everything looks copacetic, let’s print out the value of our new <code>whoAmI</code> variable:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(whoAmI);</span><br></pre></td></tr></table></figure>
<p>Outputs:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span> ? <span class="string">"window"</span> : <span class="string">"MyObj"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OK, cool. Looks fine.</p>
<p>But now, look at the difference when we invoke <code>obj.whoAmI()</code> vs. our convenience reference <code>whoAmI()</code>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj.whoAmI();  <span class="comment">// outputs "MyObj" (as expected)</span></span><br><span class="line">whoAmI();      <span class="comment">// outputs "window" (uh-oh!)</span></span><br></pre></td></tr></table></figure>
<p>What went wrong?</p>
<p>The headfake here is that, when we did the assignment <code>var whoAmI = obj.whoAmI;</code>, the new variable <code>whoAmI</code> was being defined in the <em>global</em> namespace. As a result, its value of <code>this</code> is <code>window</code>, <em>not</em> the <code>obj</code> instance of <code>MyObject</code>!</p>
<p>Thus, if we really need to create a reference to an existing method of an object, we need to be sure to do it within that object’s namespace, to preserve the value of <code>this</code>. One way of doing this would be, for example, as follows:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyObject = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">MyObject.prototype.whoAmI = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span> ? <span class="string">"window"</span> : <span class="string">"MyObj"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> MyObject();</span><br><span class="line">obj.w = obj.whoAmI;   <span class="comment">// still in the obj namespace</span></span><br><span class="line"></span><br><span class="line">obj.whoAmI();  <span class="comment">// outputs "MyObj" (as expected)</span></span><br><span class="line">obj.w();       <span class="comment">// outputs "MyObj" (as expected)</span></span><br></pre></td></tr></table></figure>
<h2 id="Common_Mistake_#9:_Providing_a_string_as_the_first_argument_to_setTimeout_or_setInterval">Common Mistake #9: Providing a string as the first argument to <code>setTimeout</code> or <code>setInterval</code></h2><p>For starters, let’s be clear on something here: Providing a string as the first argument to <code>setTimeout</code> or <code>setInterval</code> is <strong>not</strong> itself a mistake per se. It is perfectly legitimate JavaScript code. The issue here is more one of performance and efficiency. What is rarely explained is that, under the hood, if you pass in a string as the first argument to <code>setTimeout</code> or <code>setInterval</code>, it will be passed to the <em>function constructor</em> to be converted into a new function. This process can be slow and inefficient, and is rarely necessary.</p>
<p>The alternative to passing a string as the first argument to these methods is to instead pass in a <em>function</em>. Let’s take a look at an example.</p>
<p>Here, then, would be a fairly typical use of <code>setInterval</code> and <code>setTimeout</code>, passing a <em>string</em> as the first parameter:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setInterval(<span class="string">"logTime()"</span>, <span class="number">1000</span>);</span><br><span class="line">setTimeout(<span class="string">"logMessage('"</span> + msgValue + <span class="string">"')"</span>, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>The better choice would be to pass in a <em>function</em> as the initial argument; e.g.:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setInterval(logTime, <span class="number">1000</span>);   <span class="comment">// passing the logTime function to setInterval</span></span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;       <span class="comment">// passing an anonymous function to setTimeout</span></span><br><span class="line">    logMessage(msgValue);     <span class="comment">// (msgValue is still accessible in this scope)</span></span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<h2 id="Common_Mistake_#10:_Failure_to_use_“strict_mode”">Common Mistake #10: Failure to use “strict mode”</h2><p>As explained in our <a href="http://www.toptal.com/javascript#hiring-guide" target="_blank" rel="external">JavaScript Hiring Guide</a>, “strict mode” (i.e., including <code>&#39;use strict&#39;;</code> at the beginning of your JavaScript source files) is a way to voluntarily enforce stricter parsing and error handling on your JavaScript code at runtime, as well as making it more secure.</p>
<p>While, admittedly, failing to use strict mode is not a “mistake” per se, its use is increasingly being encouraged and its omission is increasingly becoming considered bad form.</p>
<p>Here are some key benefits of strict mode:</p>
<ul>
<li><strong>Makes debugging easier.</strong> Code errors that would otherwise have been ignored or would have failed silently will now generate errors or throw exceptions, alerting you sooner to problems in your code and directing you more quickly to their source.</li>
<li><strong>Prevents accidental globals.</strong> Without strict mode, assigning a value to an undeclared variable automatically creates a global variable with that name. This is one of the most common errors in JavaScript. In strict mode, attempting to do so throws an error.</li>
<li><strong>Eliminates <code>this</code> coercion</strong>. Without strict mode, a reference to a <code>this</code> value of null or undefined is automatically coerced to the global. This can cause many headfakes and pull-out-your-hair kind of bugs. In strict mode, referencing a a <code>this</code> value of null or undefined throws an error.</li>
<li><strong>Disallows duplicate property names or parameter values.</strong> Strict mode throws an error when it detects a duplicate named property in an object (e.g., <code>var object = {foo: &quot;bar&quot;, foo: &quot;baz&quot;};</code>) or a duplicate named argument for a function (e.g., <code>function foo(val1, val2, val1){}</code>), thereby catching what is almost certainly a bug in your code that you might otherwise have wasted lots of time tracking down.</li>
<li><strong>Makes eval() safer.</strong> There are some differences in the way <code>eval()</code> behaves in strict mode and in non-strict mode. Most significantly, in strict mode, variables and functions declared inside of an <code>eval()</code> statement are <em>not</em> created in the containing scope (they <em>are</em> created in the containing scope in non-strict mode, which can also be a common source of problems).</li>
<li><strong>Throws error on invalid usage of <code>delete</code>.</strong> The <code>delete</code> operator (used to remove properties from objects) cannot be used on non-configurable properties of the object. Non-strict code will fail silently when an attempt is made to delete a non-configurable property, whereas strict mode will throw an error in such a case.</li>
</ul>
<h2 id="Wrap-up">Wrap-up</h2><p>As is true with any technology, the better you understand why and how JavaScript works and doesn’t work, the more solid your code will be and the more you’ll be able to effectively harness to true power of the language. Conversely, lack of proper understanding of JavaScript paradigms and concepts is indeed where many JavaScript problems lie.</p>
<p>Thoroughly familiarizing yourself with the language’s nuances and subtleties is the most effective strategy for improving your proficiency and increasing your productivity. Avoiding many common JavaScript mistakes will help when your JavaScript is not working.</p>
<blockquote>
<p>Reprinted from <a href="http://www.toptal.com/javascript/10-most-common-javascript-mistakes" target="_blank" rel="external">toptal.com</a>.</p>
</blockquote>

      
    </div>
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Javascript/">Javascript</a></li></ul>

      </footer>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2015/09/ConnectIPv6/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">&laquoNewer</strong>
      <div class="article-nav-title">
        
          Connect IPv6 with IPv4 via tunnel
        
      </div>
    </a>
  
  
    <a href="/2015/06/SomeGitWays/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older&raquo</strong>
      <div class="article-nav-title">Some Git Ways</div>
    </a>
  
</nav>

  
</article>


<section id="comments">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>

</section>
      </div>
      <footer id="footer">
  
  <div class="outer">
	<div id="footer-info" class="inner">
	&copy; 2017 Yiming LU<br>
	Hosted on <a href="https://pages.github.com/" target="_blank">GitHub Pages</a>.
	Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>.
	</div>
  </div>
</footer>
    </div>
    
<script>
  var disqus_shortname = 'ymlu';
  
  var disqus_url = 'http://blog.seasonsroad.com/2015/06/10MostCommonJavaScriptMistakes/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

  </div>
</body>
</html>