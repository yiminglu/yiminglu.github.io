<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Autocommands | Yiming @ SeasonsRoad</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Now we’re going to look at a topic almost as important as mappings: autocommands.
Autocommands are a way to tell Vim to run certain commands whenever certain events happen.  Let’s dive right into an e">
<meta property="og:type" content="website">
<meta property="og:title" content="Autocommands">
<meta property="og:url" content="http://seasonsroad.com/LearnVimScriptTheHardWay/12.html">
<meta property="og:site_name" content="Yiming @ SeasonsRoad">
<meta property="og:description" content="Now we’re going to look at a topic almost as important as mappings: autocommands.
Autocommands are a way to tell Vim to run certain commands whenever certain events happen.  Let’s dive right into an e">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Autocommands">
<meta name="twitter:description" content="Now we’re going to look at a topic almost as important as mappings: autocommands.
Autocommands are a way to tell Vim to run certain commands whenever certain events happen.  Let’s dive right into an e">
  
    <link rel="alternative" href="/atom.xml" title="Yiming @ SeasonsRoad" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-nav" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Good Morning!</a>
      </h1>
      <nav id="main-nav">
        <ul class="mod-head__ul">
        
          <li class="main-nav-link"><a href="/">Home</a></li>
        
          <li class="main-nav-link"><a href="/links.html">Links</a></li>
        
          <li class="main-nav-link"><a href="https://github.com/yiminglu">Github</a></li>
        
          <li class="main-nav-link"><a href="/about.html">About</a></li>
        
        </ul>
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
      </nav>
    </div>
  </div>
</header>
      <div class="inner">
        <section id="main"><article id="page-undefined" class="article article-type-page" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      <a href="/LearnVimScriptTheHardWay/12.html">
        Autocommands
      </a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Now we’re going to look at a topic almost as important as mappings: autocommands.</p>
<p>Autocommands are a way to tell Vim to run certain commands whenever certain events happen.  Let’s dive right into an example.</p>
<p>Open a new file with <code>:edit foo</code> and close it right away with <code>:quit</code>.  Look on your hard drive and you’ll notice that the file is not there.  This is because Vim doesn’t actually <em>create</em> the file until you save it for the first time.</p>
<p>Let’s change it so that Vim creates files as soon as you edit them.  Run the following command:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:autocmd BufNewFile * :write</span><br></pre></td></tr></table></figure>
<p>This is a lot to take in, but try it out and see that it works.  Run <code>:edit foo</code> again, close it with <code>:quit</code>, and look at your hard drive.  This time the file will be there (and empty, of course).</p>
<p>You’ll have to close Vim to remove the autocommand.  We’ll talk about how to avoid this in a later chapter.</p>
<h2 id="Autocommand_Structure">Autocommand Structure</h2><p>Let’s take a closer look at the autocommand we just created:</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">:autocmd BufNewFile * :write</span></span><br><span class="line"></span><br><span class="line"><span class="code">     ^          ^ ^</span></span><br><span class="line"></span><br><span class="line"><span class="code">     |          | |</span></span><br><span class="line"></span><br><span class="line"><span class="code">     |          | The command to run.</span></span><br><span class="line"></span><br><span class="line"><span class="code">     |          |</span></span><br><span class="line"></span><br><span class="line"><span class="code">     |          A "pattern" to filter the event.</span></span><br><span class="line"></span><br><span class="line"><span class="code">     |</span></span><br><span class="line"></span><br><span class="line"><span class="code">     The "event" to watch for.</span></span><br></pre></td></tr></table></figure>
<p>The first piece of the command is the type of event we want to watch for.  Vim offers <em>many</em> events to watch.  Some of them include:</p>
<ul>
<li>Starting to edit a file that doesn’t already exist. <em> Reading a file, whether it exists or not. </em> Switching a buffer’s <code>filetype</code> setting. <em> Not pressing a key on your keyboard for a certain amount of time. </em> Entering insert mode. * Exiting insert mode.</li>
</ul>
<p>This is just a tiny sample of the available events.  There are many more you can use to do lots of interesting things.</p>
<p>The next part of the command is a “pattern” that lets you be more specific about when you want the command to fire.  Start up a new Vim instance and run the following command:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:autocmd BufNewFile *.txt :write</span><br></pre></td></tr></table></figure>
<p>This is almost the same as the last command, but this time it will only apply to files whose names end in <code>.txt</code>.</p>
<p>Try it out by running <code>:edit bar</code>, then <code>:quit</code>, then <code>:edit bar.txt</code>, then <code>:quit</code>.  You’ll see that Vim writes the <code>bar.txt</code> automatically, but <em>doesn’t</em> write <code>bar</code> because it doesn’t match the pattern.</p>
<p>The final part of the command is the command we want to run when the event fires.  This is pretty self-explanatory, except for one catch: you can’t use special characters like <code>&lt;cr&gt;</code> in the command.  We’ll talk about how to get around this limitation later in the book, but for now you’ll just have to live with it.</p>
<h2 id="Another_Example">Another Example</h2><p>Let’s define another autocommand, this time using a different event.  Run the following command:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:autocmd BufWritePre *.html :normal gg=G</span><br></pre></td></tr></table></figure>
<p>We’re getting a bit ahead of ourselves here because we’re going to talk about <code>normal</code> later in the book, but for now you’ll need to bear with me because it’s tough to come up with useful examples at this point.</p>
<p>Create a new file called <code>foo.html</code>.  Edit it with Vim and enter the following text <em>exactly</em>, including the whitespace:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;<span class="title">p</span>&gt;</span>Hello!<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">             <span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">              <span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Now save this file with <code>:w</code>.  What happened?  Vim seems to have reindented the file for us before saving it!</p>
<p>For now I want you to trust me that running <code>:normal gg=G</code> will tell Vim to reindent the current file.  Don’t worry about how that works just yet.</p>
<p>What we <em>do</em> want to pay attention to is the autocommand.  The event type is <code>BufWritePre</code>, which means the event will be checked just before you write <em>any</em> file.</p>
<p>We used a pattern of <code>*.html</code> to ensure that this command will only fire when we’re working on files that end in <code>.html</code>.  This lets us target our autocommands at specific files, which is a very powerful idea that we’ll continue to explore later on.</p>
<h2 id="Multiple_Events">Multiple Events</h2><p>You can create a single autocommand bound to <em>multiple</em> events by separating the events with a comma.  Run this command:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:autocmd BufWritePre,BufRead *.html :normal gg=G</span><br></pre></td></tr></table></figure>
<p>This is almost like our last command, except it will also reindent the code whenever we <em>read</em> an HTML file as well as when we write it.  This could be useful if you have coworkers that don’t indent their HTML nicely.</p>
<p>A common idiom in Vim scripting is to pair the <code>BufRead</code> and <code>BufNewFile</code> events together to run a command whenever you open a certain kind of file, regardless of whether it happens to exist already or not.  Run the following command:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:autocmd BufNewFile,BufRead *.html setlocal nowrap</span><br></pre></td></tr></table></figure>
<p>This will turn line wrapping off whenever you’re working on an HTML file.</p>
<h2 id="FileType_Events">FileType Events</h2><p>One of the most useful events is the <code>FileType</code> event.  This event is fired whenever Vim sets a buffer’s <code>filetype</code>.</p>
<p>Let’s set up a few useful mappings for a variety of file types.  Run the following commands:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:autocmd FileType javascript nnoremap &lt;buffer&gt; &lt;localleader&gt;c I//&lt;esc&gt;</span><br><span class="line"></span><br><span class="line">:autocmd FileType python     nnoremap &lt;buffer&gt; &lt;localleader&gt;c I#&lt;esc&gt;</span><br></pre></td></tr></table></figure>
<p>Open a Javascript file (a file that ends in <code>.js</code>), pick a line and type <code>&lt;localleader&gt;c</code>.  This will comment out the line.</p>
<p>Now open a Python file (a file that ends in <code>.py</code>), pick a line and type <code>&lt;localleader&gt;c</code>.  This will comment out the line, but it will use Python’s comment character!</p>
<p>Using autocommands alongside the buffer-local mappings we learned about in the last chapter we can create mappings that are specific to the type of file that we’re editing.</p>
<p>This reduces the load on our minds when we’re coding.  Instead of having to think about moving to the beginning of the line and adding a comment character we can simply think “comment this line”.</p>
<h2 id="Exercises">Exercises</h2><p>Skim <code>:help autocmd-events</code> to see a list of all the events you can bind autocommands to.  You don’t need to memorize each one right now.  Just try to get a feel for the kinds of things you can do.</p>
<p>Create a few <code>FileType</code> autocommands that use <code>setlocal</code> to set options for your favorite filetypes just the way you like them.  Some options you might like to change on a per-filetype basis are <code>wrap</code>, <code>list</code>, <code>spell</code>, and <code>number</code>.</p>
<p>Create a few more “comment this line” autocommands for filetypes you work with often.</p>
<p>Add all of these autocommands to your <code>~/.vimrc</code> file.  Use your shortcut mappings for editing and sourcing it quickly, of course!</p>
<p><a href="11.html">« Previous</a><a style="float:right" href="13.html">Next »</a></p>

      
    </div>
    
  </div>
  
</article>


</section>
      </div>
      <footer id="footer">
  
  <div class="outer">
	<div id="footer-info" class="inner">
	&copy; 2015 Yiming LU<br>
	Hosted on <a href="https://pages.github.com/" target="_blank">GitHub Pages</a>.
	Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>.
	</div>
  </div>
</footer>
    </div>
    
<script>
  var disqus_shortname = 'ymlu';
  
  var disqus_url = 'http://seasonsroad.com/LearnVimScriptTheHardWay/12.html';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

  </div>
</body>
</html>